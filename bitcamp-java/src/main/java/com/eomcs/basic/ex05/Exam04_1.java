// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam04_1 {
    public static void main(String[] args) {
      
      System.out.println(3 << 1);
      //   000000000 000000000 000000000 000000011 : 3
      // 0|000000000 000000000 000000000 00000011x : 3 << 1 (비트이동)
      //   000000000 000000000 000000000 000000110 : 6
      
      System.out.println(3 << 33);
      System.out.println(3 << 65);
      System.out.println(3 << 97);
      
      // 3 에 33 비트를 이동하나, 65비트를 이동하나 97비트를 이동하나
      // 같은 값이 나오는 이유?
      // >> int type 타입의 값에 대해 비트 이동을 할 때는 0 ~ 31까지만 유효하다.
      //    만약 31을 넘는 경우 32로 나눈 나머지 값을 비트 이동으로 간주한다.
      // >> long 타입의 경우 비트이동은 0 ~ 63까지 유효하다.
      //    만약 63을 넘는 경우  64로 나눈 나머지 값을 비트이동으로 간주한다.
      
      // int 값에 대한 비트 이동은 0 ~ 31 이다.
      // long 값에 대한 비트 이동은 0 ~ 63 이다.
      // 비트이동 유효범위를 벗어난다면 ?
      // >> int 데이터인 경우 비트 이동 값은 하위 5비트만 유효하다.
      // >> long 데이터인 경우 비트 이동 값은 하위 6비트만 유효하다.
      // 예)
      // n << s
      // - n 이 int 타입이라면, 다음 계산을 통해  s의 값에서 하위 5비트만 취한다.
      // s & 0b111111 = 비트 이동
      //    따라서 s의 값은 무조건 0 ~ 31이다.
      //    결국 s의 값은 s % 32의 결과와 갖다
      // - n 이 long 타입이라면, 다음 계산을 통해 s의 하위 6비트만 취한다
      // s & 0b111111 = 비트이동
      //    따라서 s의 값은 무조건 0 ~ 63이다.
      //    결국 s의 값은 s % 64의 결과와 갖다
      // 
      // 예)
      // 3 << 33
      //   n = 00000000 00000000 00000000 00000011 = 33
      //   s = 00000000 00000000 00000000 00100001 = 33 
      //   비트이동 >> s & 0b111111
      //       00000000 00000000 00000000 00100001 = 33
      //     & 00000000 00000000 00000000 00011111
      // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
      //       00000000 00000000 00000000 00000001 = 1
      // 따라서, 최종 비트이동값을 계산하면 다음과 같다.
      // 3 << 33 = 3 << 1
      // 
      // 비트 이동 계산의 근거 Java Language Specification 에서 찾아보셈
    }
}
